#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/47cecbde-beec-4923-81ff-3aa4a3b9595c 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float diff;
  float kp;
  int power;
  bool start;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include "SerialCommand.h"
#include "EEPROMAnything.h"

#define SerialPort Serial
#define Baudrate 115200
#define MotorLeftForward 18
#define MotorLeftBackward 19
#define MotorRightForward 21
#define MotorRightBackward 22
#define PWMA 17
#define PWMB 23
#define ledSensor 12

SerialCommand sCmd(SerialPort);
bool debug;
bool run;
float iTerm = 0;
float lastErr;
unsigned long previous, calculationTime;

const int sensor[] = {36, 39, 34, 35, 32, 33};


struct param_t
{
  unsigned long cycleTime;
  /* andere parameters die in het eeprom geheugen moeten opgeslagen worden voeg je hier toe ... */
  int black[6];
  int white[6];
  int power;
  float diff;
  float kp;
  float ki;
  float kd;
} params;

  int normalised[6];
  float debugPosition;

  void onKnownCommand(char *command);
  void onSet();
  void onDebug();
  void onCalibrate();
  void onRun();


void setup() {
  SerialPort.begin(Baudrate);
  EEPROM.begin(512);
  sCmd.addCommand("set", onSet);
  sCmd.addCommand("debug", onDebug);
  sCmd.addCommand("run", onRun);
  sCmd.addCommand("calibrate", onCalibrate);
  sCmd.setDefaultHandler(onUnknownCommand);

  pinMode(MotorLeftForward, OUTPUT);
  pinMode(MotorLeftBackward, OUTPUT);
  pinMode(MotorRightForward, OUTPUT);
  pinMode(MotorRightBackward, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(ledSensor, OUTPUT);


  digitalWrite(PWMA, HIGH);
  digitalWrite(PWMB, HIGH);

  pinMode(2, OUTPUT);
  digitalWrite(2, LOW);   // uit = niet verbonden


  EEPROM_readAnything(0, params);
  power = params.power;
  diff = params.diff;
  kp = params.kp;

  SerialPort.println("ready"); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  sCmd.readSerial();
  digitalWrite(ledSensor, HIGH);
  // LED indicatie voor IoT Cloud verbinding
  if (ArduinoCloud.connected()) {
    digitalWrite(2, HIGH);   // verbonden
  } else {
    digitalWrite(2, LOW);    // niet verbonden
  }

  // for (int i = 0; i<8; i++)
  //   {
  //     Serial.print(analogRead(sensor[i]));
  //     Serial.print(" ");
  //   }
  //   Serial.println();
    
  unsigned long current = micros();
  if (run && (current - previous >= params.cycleTime)) {
    previous = current;

    
    
    // --- Sensor normalisatie ---
    for (int i = 0; i < 6; i++)
    {
      normalised[i] = map(analogRead(sensor[i]), params.black[i], params.white[i], 0, 4096);
      SerialPort.print(normalised[i]);
      SerialPort.print(" ");
      normalised[i] = constrain(normalised[i], 0, 4096);
    } 
    SerialPort.println();
    


    // interpolate
    float position = 0;
    int index = 0;
    for (int i = 1; i < 6; i++) if (normalised[i] < normalised[index]) index = i;

    // controle: zijn ALLE sensoren wit? -> motoren uit!
    if (normalised[index] > 3000) run = false;

    if (index == 0) position = -30;
    else if (index == 5) position = 30;
    else {
      int sNul = normalised[index];
      int sMinEen = normalised[index - 1];
      int sPlusEen = normalised[index + 1];

      float b = sPlusEen - sMinEen;
      b = b / 2; 

      float a = sPlusEen - b - sNul;

      position = -b / (2 * a);
      position += index;
      position -= 3.5;
      position *= 10;      // afstand tussen 2 sensoren 9,52 cm
    }
    debugPosition = position;

    /* bereken error = setpoint - positie */
    float error = -position;

    /* proportioneel regelen */
    float output = error * params.kp;

    /* integrerend regelen */
    iTerm += params.ki * error;
    iTerm = constrain(iTerm, -510, 510);
    output += iTerm; 

    /* differentiërend regelen */
    output += params.kd * (error - lastErr);
    lastErr = error; 

    /* output begrenzen tot wat fysiek mogelijk is */
    output = constrain(output, -510, 510);

    int powerLeft = 0;
    int powerRight = 0;

    if (output >= 0) {
      powerLeft = constrain(params.power + params.diff * output, -255, 255);
      powerRight = constrain(powerLeft - output, -255, 255);
      powerLeft = powerRight + output;
    } else {
      powerRight = constrain(params.power - params.diff * output, -255, 255);
      powerLeft = constrain(powerRight + output, -255, 255);
      powerRight = powerLeft - output;
    }

    analogWrite(MotorRightForward, powerLeft > 0 ? powerLeft : 0);
    analogWrite(MotorRightBackward, powerLeft < 0 ? -powerLeft : 0);
    analogWrite(MotorLeftForward, powerRight > 0 ? powerRight : 0);
    analogWrite(MotorLeftBackward, powerRight < 0 ? -powerRight : 0);
  }

  // --- Cyclustijd meten voor debug ---
  unsigned long difference = micros() - current;
  if (difference > calculationTime) calculationTime = difference;
}


void onUnknownCommand(char *command)
{
  SerialPort.print("unknown command: \"");
  SerialPort.print(command);
  SerialPort.println("\"");
}

void onSet()
{
  char *param = sCmd.next();
  char *value = sCmd.next();

  if (strcmp(param, "cycle") == 0)
  {
    long newCycleTime = atol(value);
    float ratio = ((float) newCycleTime) / ((float) params.cycleTime);
    params.ki *= ratio;
    params.kd /= ratio;
    params.cycleTime = newCycleTime;
  }
  else if (strcmp(param, "power") == 0) params.power = atol(value); // de snelheid waarmee de robot rijd!
  else if (strcmp(param, "diff") == 0) params.diff = atof(value); // trager of sneller rijden als de fout groot of klein is! tussen 0 en 1! (voor in de bochten)!
  else if (strcmp(param, "kp") == 0) params.kp = atof(value); // de grootte waarmee de roobot zijn fout corrigeerd!
  else if (strcmp(param, "ki") == 0)
  {
    float cycleTimeInSec = ((float) params.cycleTime) / 1000000;
    params.ki = atof(value) * cycleTimeInSec;
  }
  else if (strcmp(param, "kd") == 0)
  {
    float cycleTimeInSec = ((float) params.cycleTime) / 1000000;
    params.kd = atof(value) / cycleTimeInSec;
  }

  /* parameters een nieuwe waarde geven via het set commando doe je hier ... */
  EEPROM_writeAnything(0, params);
  EEPROM.commit();
}

void onDebug()
{
  SerialPort.print("cycle time: ");
  SerialPort.println(params.cycleTime);
  
  /* parameters weergeven met behulp van het debug commando doe je hier ... */
  SerialPort.print("black: ");
  for (int i = 0; i<6; i++)
  {
    SerialPort.print(params.black[i]);
    SerialPort.print(" ");
  }
  SerialPort.println(" ");

  SerialPort.print("white: ");
  for (int i = 0; i<6; i++)
  {
    SerialPort.print(params.white[i]);
    SerialPort.print(" ");
  }
  SerialPort.println(" ");

  SerialPort.print("normalised: ");
  for (int i = 0; i<6; i++)
  {
    SerialPort.print(normalised[i]);
    SerialPort.print(" ");
  }
  SerialPort.println();

  SerialPort.print("position: ");
  SerialPort.println(debugPosition);

  SerialPort.print("power: ");
  SerialPort.println(params.power);
  SerialPort.print("diff: ");
  SerialPort.println(params.diff);
  SerialPort.print("kp: ");
  SerialPort.println(params.kp);

  float cycleTimeInSec = ((float) params.cycleTime) / 1000000;
  float ki = params.ki / cycleTimeInSec;
  SerialPort.print("Ki: ");
  SerialPort.println(ki);

  float kd = params.kd * cycleTimeInSec;
  SerialPort.print("Kd: ");
  SerialPort.println(kd);
  
  SerialPort.print("calculation time: ");
  SerialPort.println(calculationTime);
  calculationTime = 0;
}

void onCalibrate()
{
  char* param = sCmd.next();
  if (strcmp(param, "black") == 0)
  {
    SerialPort.print("start calibrating black ... ");
    for (int i = 0; i< 6; i++) params.black[i] = analogRead(sensor[i]);
    SerialPort.println("done");
  }
  else if (strcmp(param, "white") == 0)
  {
    SerialPort.print("start calibrating white ... ");
    for (int i = 0; i< 6; i++) params.white[i] = analogRead(sensor[i]);
    SerialPort.println("done");
  }
  
  EEPROM_writeAnything(0, params);
  EEPROM.commit();

}

void onRun() {
  run = true;
  iTerm = 0;
  SerialPort.println("RUN command ontvangen");
}

void stopMotors() {
  analogWrite(MotorLeftForward, 0);
  analogWrite(MotorLeftBackward, 0);
  analogWrite(MotorRightForward, 0);
  analogWrite(MotorRightBackward, 0);
}

/*
  Since Start is READ_WRITE variable, onStartChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onStartChange()  {
  // Add your code here to act upon Start change
  if (start) {
    run = true;
    iTerm = 0;
    SerialPort.println("Robot gestart via IoT Cloud!");
  } else {
    run = false;
    stopMotors();
    SerialPort.println("Robot gestopt via IoT Cloud!");
  }
}

/*
  Since Power is READ_WRITE variable, onPowerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPowerChange()  {
  // Add your code here to act upon Power change
  params.power = power;       // cloud → struct
  EEPROM_writeAnything(0, params);
  EEPROM.commit();
  Serial.println("Power updated from IoT Cloud");
}

/*
  Since Diff is READ_WRITE variable, onDiffChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDiffChange()  {
  // Add your code here to act upon Diff change
  params.diff = diff;         // cloud → struct
  EEPROM_writeAnything(0, params);
  EEPROM.commit();
  Serial.println("Diff updated from IoT Cloud");
}

/*
  Since Kp is READ_WRITE variable, onKpChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onKpChange()  {
  // Add your code here to act upon Kp change
  params.kp = kp;             // cloud → struct
  EEPROM_writeAnything(0, params);
  EEPROM.commit();
  Serial.println("KP updated from IoT Cloud");
}